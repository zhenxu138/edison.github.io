<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>数据库学习-SORM组件学习 | edison&#39;s blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zhenxu138.github.io/edison.github.io/favicon.ico?v=1634207698339">
<link rel="stylesheet" href="https://zhenxu138.github.io/edison.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="公共组件做了数据库抽象层：sorm，所以业务不直接写数据库原生的sql，遵循sorm组件语法开发
1.模型的概念：
模型就是数据库的表结构，对应到go中就是go的结构体，可以通过给结构体增加orm属性的tag来指定这个字段的属性，比如主键,..." />
    <meta name="keywords" content="数据库,sorm" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zhenxu138.github.io/edison.github.io">
        <img src="https://zhenxu138.github.io/edison.github.io/images/avatar.png?v=1634207698339" class="site-logo">
        <h1 class="site-title">edison&#39;s blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      lazy man daily context
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">gridea</a> | <a class="rss" href="https://zhenxu138.github.io/edison.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">数据库学习-SORM组件学习</h2>
            <div class="post-date">2021-10-14</div>
            
            <div class="post-content" v-pre>
              <p>公共组件做了数据库抽象层：sorm，所以业务不直接写数据库原生的sql，遵循sorm组件语法开发</p>
<h3 id="1模型的概念">1.模型的概念：</h3>
<p>模型就是数据库的<mark>表结构</mark>，对应到go中就是go的结构体，可以通过给结构体增加orm属性的tag来指定这个字段的属性，比如主键,索引等。</p>
<pre><code class="language-go">type TessResultDetail struct {
   Id       int64  `orm:&quot;pk;column(_id)&quot; bson:&quot;_id&quot;`
   ResultId int64  `orm:&quot;index;column(result_id)&quot; bson:&quot;result_id&quot;`
   CheckId  string `orm:&quot;index;column(check_id)&quot; bson:&quot;check_id&quot; `
   Name     string `orm:&quot;column(name)&quot; bson:&quot;name&quot; json:&quot;name&quot;`
   Score int32 `bson:&quot;score&quot; json:&quot;score&quot;`
   Scope int32 `bson:&quot;scope&quot; json:&quot;scope&quot;`
   CheckStd string `bson:&quot;check_std&quot; json:&quot;check_std&quot;`
   Result int32 `bson:&quot;result&quot; json:&quot;result&quot;` 
   Description  string `bson:&quot;description&quot; json:&quot;description&quot;`
   Extend       string `bson:&quot;extend&quot; json:&quot;extend&quot;`
   CheckContent string `bson:&quot;check_content&quot; json:&quot;check_content&quot;`
}
</code></pre>
<p>模型初始化，模型注册</p>
<pre><code class="language-go">func init() {
  	orm.RegisterModel(new(model.TessResultDetail))
    o := orm.NewOrmWithDb(provider.DefaultDB())
    o.RegisterTable(new(model.TessResultDetail))
}
</code></pre>
<p>ORM模型对象的组成：</p>
<ul>
<li>表名table</li>
<li>主键</li>
<li>索引（普通索引，UNIQUE 索引，组合索引）</li>
<li>表列（列名）</li>
<li>关联表对象</li>
<li>支持的数据类型以及标注</li>
</ul>
<h5 id="数据库注册">数据库注册</h5>
<pre><code>//注册数据库示例：
var info orm.OrmDbRegisterInfo
info.DbType = &quot;mongo&quot;
info.Host = &quot;127.0.0.1:27017&quot;
...
info.AliasName = &quot;default&quot;//必须指定一个default数据库，通过这里的别名实现
initSetting := make(map[string]string)
initSetting[&quot;create_table&quot;] = &quot;true&quot;
info.Opts = initSetting//设置选项
 
orm.RegisterDataBaseWithOpt(info)
</code></pre>
<h2 id="2基本api">2.基本API</h2>
<h4 id="查找read">查找read</h4>
<h5 id="1根据某一值查找单条数据func-o-orm-readone-value-interface-fields-string-error">1.根据某一值查找单条数据：func ( o *orm ) ReadOne (value interface{} , fields ... string ) error</h5>
<pre><code class="language-go">user := User{UId: &quot;100001199508049527&quot;}
err = o.ReadOne(&amp;user,&quot;UId&quot;)

sd := &amp;model.Standard{Id: id}
err := orm.NewOrmWithDb(s.hook.DefaultDB()).ReadOne(sd, &quot;_id&quot;)
</code></pre>
<h5 id="2查找或创造funco-orm-readoneorcreate-value-interface-field1-string-fields-string-bool-error">2.查找或创造：func(o *orm) ReadOneOrCreate (value interface{}, field1 string, fields ...string) (bool, error)</h5>
<pre><code class="language-go">o := orm.NewOrm()
user := User{Name: &quot;Jeff&quot;}
user := User{UId: &quot;100001199508049527&quot;}
if created, err := o.ReadOneOrCreate(&amp;user, &quot;UId&quot;); err == nil {
  if created {
    fmt.Println(&quot;New Insert an object. Id:&quot;, id)
  } else{
    fmt.Println(&quot;Get an object. Id:&quot;, id)
  }
}
</code></pre>
<h4 id="插入数据">插入数据</h4>
<h5 id="1插入一条数据func-o-orm-insertvalue-interface-error">1.插入一条数据：func( o *orm )Insert(value interface{}) error</h5>
<pre><code class="language-go">var user User
user.Name = &quot;Jack&quot;
err := o.Insert(&amp;user)

standar := model.NewStandard(id, name, assetID, desc, creator, clientType, isInner)
err := orm.NewOrmWithDb(s.hook.DefaultDB()).Insert(standar)
</code></pre>
<h5 id="2插入多条func-o-orm-insertmultiint-bulkvalues-interface-opt-ormorminsertmultiopt-int64error">2.插入多条：func( o *orm )InsertMulti(int bulk,values [] interface{}, opt ...orm.OrmInsertMultiOpt) (int64,error)</h5>
<pre><code class="language-go">users := []User{
  {Name: &quot;Jack&quot;},
  {Name: &quot;Bob&quot;},
  {Name: &quot;unknown&quot;},
  ...
}
successNums, err := o.InsertMulti(len(users), &amp;users)
</code></pre>
<h4 id="更改数据">更改数据</h4>
<h5 id="1更改单条数据func-o-orm-updatevalue-interface-fields-string-int64-error">1.更改单条数据：func ( o *orm )Update(value interface{} , fields ... string )(int64, error)</h5>
<pre><code class="language-go">//更新全部字段
o := orm.NewOrm()
user := User{ID: &quot;1&quot;}
if o.Read(&amp;user) == nil {
  user.Name = &quot;MyName&quot;
  if num, err := o.Update(&amp;user); err == nil {
    fmt.Println(num)
  }
}
</code></pre>
<h5 id="2更改单条数据的某个数据">2.更改单条数据的某个数据</h5>
<pre><code class="language-go">o.Update(&amp;user, &quot;Name&quot;)
// 指定多个字段
// o.Update(&amp;user, &quot;Field1&quot;, &quot;Field2&quot;, ...)
</code></pre>
<h5 id="3插入或更改func-s-orm-insertorupdatemd-interface-uniquecols-string-updatecols-string-error">3.插入或更改：func (s *Orm) InsertOrUpdate(md interface{}, uniquecols []string, updatecols ...string) error</h5>
<pre><code>//根据联合唯一索引Name 和 Age 匹配，若数据库存在则更新所有字段，否则插入该条数据
err := o.InsertOrUpdate(intnew, []string{&quot;Name&quot;, &quot;Age&quot;})
</code></pre>
<pre><code class="language-go">//根据联合唯一索引Name 和 Age 匹配，若数据库存在,只更新&quot;Addr&quot;, &quot;Level&quot;字段，否则插入该条数据
err = o.InsertOrUpdate(intnew, []string{&quot;Name&quot;, &quot;Age&quot;}, []string{&quot;Addr&quot;,&quot;Level&quot;}...)
</code></pre>
<h4 id="删除数据">删除数据</h4>
<h5 id="1删除-funco-orm-deletevalue-interface-error根据主键进行删除">1.删除： func(o *orm) Delete(value interface{}) error//根据主键进行删除</h5>
<pre><code class="language-go">o := orm.NewOrm()
user := User{UId: ``&quot;100001199508049527&quot;``}
o.ReadOne(&amp;user, ``&quot;UId&quot;``)
err:= o.Delete(user)
if err != nil{
  fmt.Println(err)
}
</code></pre>
<h3 id="3复杂查询querytable">3.复杂查询QueryTable</h3>
<pre><code>type User struct {
    ID   string `orm:&quot;pk&quot;`
    Name string
}
//使用结构体对象
var user User
qs :=orm.NewOrm().QueryTable(user)
//使用结构体指针
if qs == nil {
  log.Errorf(&quot;QueryTable got QuerySet nil&quot;)
}
user := new(User)
qs :=orm.NewOrm().QueryTable(user)
if qs == nil {
    log.Errorf(&quot;QueryTable got QuerySet nil&quot;)
}
</code></pre>
<h4 id="1-withfilter操作范围符">1. WithFilter操作范围符</h4>
<h5 id="exact等于">exact等于</h5>
<pre><code>qs.WithFilter(&quot;name__exact&quot;, &quot;Jack&quot;) // WHERE name = 'Jack'
</code></pre>
<h5 id="ne不等于">ne不等于</h5>
<pre><code>qs.WithFilter(``&quot;age__ne&quot;``, 17)// WHERE age != 17
</code></pre>
<h5 id="gt-gte-大于-大于等于">gt / gte 大于 / 大于等于</h5>
<pre><code>qs.WithFilter(``&quot;age__gt&quot;``, 17)``// WHERE age &gt; 17` 
qs.WithFilter(``&quot;age__gte&quot;``, 18)``// WHERE age &gt;= 18
</code></pre>
<h5 id="lt-lte-小于-小于等于">lt / lte 小于 / 小于等于</h5>
<pre><code>qs.WithFilter(``&quot;age__lt&quot;``, 17)// WHERE age &lt; 17
</code></pre>
<pre><code>qs.WithFilter(``&quot;age__lte&quot;``, 18)// WHERE age &lt;= 18
</code></pre>
<h5 id="containsicontains-包含">contains/icontains 包含</h5>
<pre><code>qs.WithFilter(``&quot;name__contains&quot;``, ``&quot;Jack&quot;``)``// 大小写敏感, 匹配包含 Jack的字符qs.WithFilter(``&quot;name__icontains&quot;``, ``&quot;JACK&quot;``)``// 不区分大小写, 匹配包含 Jack的字符
</code></pre>
<h5 id="startwithistartwith以-起始">startwith/istartwith以。。。起始</h5>
<pre><code>qs.WithFilter(``&quot;name__startwith&quot;``, ``&quot;Jack&quot;``)// 大小写敏感, 匹配以 'Jack' 起始的字符串
qs.WithFilter(``&quot;name__istartwith&quot;``, ``&quot;JACK&quot;``)// 不区分大小写, 匹配以 'Jack' 起始的字符串
</code></pre>
<h5 id="endwithiendwith-以-结束">endwith/iendwith 以。。结束</h5>
<pre><code>qs.WithFilter(``&quot;name__endwith&quot;``, ``&quot;Jack&quot;``)``// 大小写敏感, 匹配以 'Jack' 结束的字符串qs.WithFilter(``&quot;name__endwith&quot;``, ``&quot;JACK&quot;``)``// 不区分大小写, 匹配以 'Jack' 结束的字符串
</code></pre>
<h5 id="in在集合中">in在集合中</h5>
<pre><code>ids:=[]``int``{17,18,19,20}``qs.WithFilter(``&quot;age__in&quot;``, ids)``// WHERE age IN (17, 18, 19, 20)
</code></pre>
<h4 id="2withfilter过滤查询">2.<strong>WithFilter</strong>过滤查询</h4>
<h5 id="count查询返回数量">count：查询返回数量</h5>
<pre><code>qs := orm.QueryTable(``new``(User))
qs := qs.WithFilter(&quot;name&quot;``, ``&quot;Jack&quot;``)
num,err := qs.Count())
</code></pre>
<h5 id="all返回结果集结果切片">all：返回结果集（结果切片）</h5>
<pre><code>qs := orm.QueryTable(``new``(User))``
qs := qs.WithFilter(``&quot;name&quot;``, ``&quot;Jack&quot;``)`
`var users []*User``
num,err := qs.All(&amp;users,``&quot;name&quot;``)
</code></pre>
<h5 id="one查询结构集中的单条记录">one：查询结构集中的单条记录。</h5>
<h5 id="oneautolnc对结果集单条记录">oneAutolnc:对结果集单条记录</h5>
<h5 id="withorderby对查询结果集进行排序">withorderby:对查询结果集进行排序</h5>
<h5 id="withlimit限制数据条数和偏移">withlimit:限制数据条数和偏移</h5>
<pre><code class="language-go">QueryTable(new(model.TessResult)).WithFilter(&quot;mid&quot;, mid).WithLimit(1, 0).WithOrderBy(&quot;created_at&quot;, -1).One(info)
</code></pre>
<h5 id="distinct查询不重复的">Distinct:查询不重复的</h5>
<h5 id="newgroupby分组操作func-s-queryset-newgroupsgroupbycols-string-groups">Newgroupby：分组操作=func (s *QuerySet) NewGroups(groupByCols []string) *Groups</h5>
<pre><code>qs := orm.QueryTable(new(User))
qs := qs.WithFilter(``&quot;name&quot;``, ``&quot;Jack&quot;)//Count聚合操作rs,err := qs.NewGroups([]string{``&quot;age&quot;``}).Count()``//Sum聚合操作//rs,err := qs.NewGroups([]string{&quot;age&quot;}).Sum(&quot;salary&quot;)``//Max聚合操作``//rs,err := qs.NewGroups([]string{&quot;age&quot;}).Max(&quot;salary&quot;)``//Min聚合操作``//rs,err := qs.NewGroups([]string{&quot;age&quot;}).Min(&quot;salary&quot;)``//Avg聚合操作``//rs,err := qs.NewGroups([]string{&quot;age&quot;}).Avg(&quot;salary&quot;)
</code></pre>
<h5 id="qsupdate批量更新func-s-queryset-qsupdatevalues-mapstringinterface-int64-error">QsUpdate：批量更新==func (s *QuerySet) QsUpdate(values map[string]interface{}) (int64, error)</h5>
<pre><code>val := make(map[string]interface{})``
val[``&quot;name&quot;``] = ``&quot;Bob&quot;``
num, err := o.QueryTable(``new``(User)).WithFilter(``&quot;name&quot;``,``&quot;Jack&quot;``).QsUpdate(val)``
fmt.Printf(``&quot;Matched Num: %s, %s&quot;``, num, err)``
// SET name = &quot;Bob&quot; WHERE name = &quot;Jack&quot;
</code></pre>
<h5 id="qsdelete">QsDelete</h5>
<pre><code>num, err := o.QueryTable(new(User)).WithFilter(``&quot;name&quot;``, ``&quot;Jack&quot;``).QsDelete()
fmt.Printf(``&quot;Affected Num: %s, %s&quot;``, num, err)
// DELETE FROM user WHERE name = &quot;Jack&quot;
</code></pre>
<h4 id="关联查询连接">关联查询（连接）</h4>
<h5 id="func-s-queryset-withloadrelatedcols-string-queryset">func (s *QuerySet) WithLoadRelated(cols ...string) *QuerySet</h5>
<p>问题：关联的时候先withfilter.再使用withloadrelated对这一结构中的关联数据限制</p>
<pre><code>type ClientPatchData struct {      
    ID       string `orm:&quot;pk;size(128);column(_id);auto&quot;`
 
    ClientMeta *Meta  `orm:&quot;rel(one,ref=MetaID)&quot;`
    //MetaID为1:1关联关系存储ID列，业务无需关心此字段也不允许操作此字段，此字段类型必须与Meta主键类型一致
    MetaID     string `orm:&quot;size(128);column(meta_id)&quot;`
 
    Kbids   []*Kbid         `orm:&quot;rel(m2m)&quot;`
}
//查出ClientPatchData.ID=&quot;ClientPatchData_ID&quot;的一条数据，同时查出与之关联的Meta和Kbid数据;关联关系的建立详看Association相关api
qsPatch := ``new``(ClientPatchData)
err := o.QueryTable(qsPatch).WithFilter(``&quot;ID&quot;``, ``&quot;ClientPatchData_ID&quot;``).WithLoadRelated(``&quot;ClientMeta&quot;``,``&quot;Kbids&quot;``).One(qsPatch)
</code></pre>
<h5 id="withcond自定义条件表达式">withcond自定义条件表达式</h5>
<pre><code>/ and AndCond (and AndNot orNot OrNotCond (and AndNot))假设0123456789这10个值
qs := o.QueryTable(user)
cond := orm.NewCondition().And(``&quot;name__contains&quot;``,``&quot;Test_Condition&quot;``))
cond1 := cond.AndNot(``&quot;age__gt&quot;``, users[3].Age).OrNot(``&quot;age__gt&quot;``, users[4].Age) ``//!(&gt;3)||!(&gt;4) 等价于 &lt;=3||&lt;=4     result:01234
cond2 := cond.AndNot(``&quot;age__gt&quot;``, users[5].Age)                 //!(&gt;5) 等价于 &lt;=5           result:012345
cond3 := cond1.OrNotCond(cond2)                        //01234||!(012345) 等价于 01234||6789 result:012346789
qs.WithCond(cond.AndCond(cond3))
qs.All(userResults)                              //result:012346789
</code></pre>
<p>首先要newcondition得到。</p>
<h4 id="withjoin连接操作">=<mark>Withjoin：连接操作</mark>=</h4>
<p>func (s *QuerySet) WithJoin( joinMode string, qsRight *QuerySet, on *Condition) *QuerySet</p>
<p>问题：不是很会</p>
<h2 id="associationdotransaction">Association，DoTransaction：</h2>
<p>对关联数据操作时，两个表，需要使用事务。</p>
<pre><code>err := so.DoTransaction(func() error {
		err := so.Delete(info)
		if err != nil {
			log.Errorf(&quot;DeleteStandardMeta rule: %v error: %+v&quot;, info, err)
			return err
		}
		_, err = so.QueryTable(new(model.StandardCheck)).WithFilter(&quot;standard&quot;, info.Id).QsDelete()
		if err != nil {
			log.Errorf(&quot;DeleteStandardCheck rule: %v error: %+v&quot;, info, err)
			return err
		}
		return nil
	})
	return err
}
</code></pre>
<h5 id="是一对一多对多关联关系的增加更新删除等操作接口每一个操作都自带事务">是一对一，多对多关联关系的增加，更新，删除等操作接口，每一个操作都自带事务。</h5>
<p>1.先删除关联关系，再删除数据。</p>
<p>先删除model.Standard，再删除相关联的model.StandardCheck。</p>
<h3 id="migration能力">Migration能力：</h3>
<p>为服务端软件升级带来的数据库存储层面，提供通用的数据库升级相关的基础能力。</p>
<p>用来链接数据库、检查数据库存在、创建数据库和关闭数据库的接口。</p>
<p>作业：</p>
<ol>
<li>找一个环境（本地或者开发机都可以）安装mongo和PostgreSQL</li>
<li>用命令行完成数据操作命题（手写sql）：
<ol>
<li>新建一个school库</li>
<li>新建student （包含id，姓名、班级id、年龄 字段） 和 class（包含id，名称）表，</li>
<li>插入2条class数据，5条student数据</li>
<li>将所有学生年龄 + 1</li>
<li>获取每个班的平均年龄、总人数、班级名称</li>
<li>删除一个学生信息</li>
</ol>
</li>
</ol>
<p>问题：</p>
<p>\l 查看数据库</p>
<p>\c进入数据库</p>
<p>\d查看表</p>
<p>1.注册表=注册模型？</p>
<p>先要注册模型，然后连接数据库后。注册表再来使用使用表，进行操作。</p>
<p>2.怎么设置关联？</p>
<pre><code>//学生表
type StudentOne struct {
   ID string    `orm:&quot;size(128);pk;auto&quot;`
   Name string  `orm:&quot;size(128)&quot;`
   Class *ClassOne `orm:&quot;rel(one,ref=StudentClassID)&quot;`//只需要再顶一个id。
   StudentClassID string`orm:&quot;size(128);colum(student_class_id)&quot;`
   Age int
   motto string
}
//班级表
type ClassOne struct {
   ID string `orm:&quot;pk;size(128);column(_id);auto&quot;`
   Name string`orm:&quot;size(128);column(name)&quot;`
}
</code></pre>
<p>CheckRelationLable check rel ref col on table student col ClassID got error</p>
<p>使用步骤：</p>
<p>1.设置数据库的信息ingo</p>
<pre><code>initSetting := make(map[string]string)
initSetting[&quot;create_table&quot;] = &quot;true&quot;
initSetting[&quot;no-framework&quot;] = &quot;true&quot;
var info orm.OrmDbRegisterInfo
info.User = &quot;postgres&quot;
info.Psw = &quot;QAXwolaile12345&quot;
info.Host = &quot;localhost:5432&quot;
info.DbType = &quot;pg&quot;
info.DbName = &quot;school&quot;
info.Opts = initSetting
info.AliasName = &quot;default&quot;
</code></pre>
<p>2.在orm对象中注册数据库信息，连接数据库。</p>
<pre><code>e := orm.RegisterDataBaseWithOpt(info)
if e != nil {
   log.Println(e)
}
</code></pre>
<p>3.连接以后，选择使用的数据表，注册模型。</p>
<pre><code>//学生表
type StudentOne struct {
   ID             string    `orm:&quot;size(128);pk;auto&quot;`
   Name           string    `orm:&quot;size(128)&quot;`
   Class          *ClassOne `orm:&quot;rel(one,ref=StudentClassID)&quot;`
   StudentClassID string    `orm:&quot;size(128);colum(student_class_id)&quot;`
   Age            int
   motto          string
}

//班级表
type ClassOne struct {
   ID   string `orm:&quot;pk;size(128);column(_id);auto&quot;`
   Name string `orm:&quot;size(128);column(name)&quot;`
}
</code></pre>
<pre><code>orm.RegisterModel(new(StudentOne), new(ClassOne))
</code></pre>
<p>4.注册模型以后，就选择不同的表进行操作，没有表名就自动创建&quot;student_dynamic&quot;。</p>
<pre><code>e = orm.NewOrm().RegisterTable(new(StudentOne), &quot;student_dynamic&quot;)
if e != nil {
   log.Println(e)
}
</code></pre>
<p>5.要对不同表进行操作时，首先对orm对象进行申请，然后用orm的usingTable进行指定表名。</p>
<pre><code>//orm对象申请（因为已经注册了缺省数据库，所以直接调用）
o := orm.NewOrm()
//指定表结构
o.UsingTable(&quot;student_dynamic&quot;)
</code></pre>
<p>6.然后根据需求进行API操作。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zhenxu138.github.io/edison.github.io/tag/kdLeRbgmb/" class="tag">
                    数据库
                  </a>
                
                  <a href="https://zhenxu138.github.io/edison.github.io/tag/Z7G7H_f0se/" class="tag">
                    sorm
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://zhenxu138.github.io/edison.github.io/post/git-he-bing-wen-ti/">
                  <h3 class="post-title">
                    Git合并问题
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
