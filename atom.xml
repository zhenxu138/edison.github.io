<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhenxu138.github.io/edison.github.io</id>
    <title>edison&apos;s blog</title>
    <updated>2021-10-15T10:59:41.198Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhenxu138.github.io/edison.github.io"/>
    <link rel="self" href="https://zhenxu138.github.io/edison.github.io/atom.xml"/>
    <subtitle>lazy man daily context</subtitle>
    <logo>https://zhenxu138.github.io/edison.github.io/images/avatar.png</logo>
    <icon>https://zhenxu138.github.io/edison.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, edison&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[go学习-闭包、回调函数]]></title>
        <id>https://zhenxu138.github.io/edison.github.io/post/go-xue-xi-bi-bao-hui-diao-han-shu/</id>
        <link href="https://zhenxu138.github.io/edison.github.io/post/go-xue-xi-bi-bao-hui-diao-han-shu/">
        </link>
        <updated>2021-10-15T07:37:34.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1匿名函数">1.匿名函数</h4>
<pre><code class="language-go">    //带参数的匿名函数
    func(i, j int32) { //自动推导
        fmt.Println(&quot;i= &quot;, i)
        fmt.Println(&quot;j= &quot;, j)
    }(10, 20) //圆括号代表调用匿名函数
</code></pre>
<h4 id="2回调函数">2.回调函数</h4>
<p>就是设置通用方法，提供一个接口，让使用外部去实现里面的具体方法。</p>
<pre><code>type Callback func(x, y int) int

// 提供一个接口，让外部去实现
func test(x, y int, callback Callback) int {
    return callback(x, y)
}

// 回调函数的具体实现
func add(x, y int) int {
    return x + y
}

func main() {
    x, y := 1, 2
    fmt.Println(test(x, y, add))
}
</code></pre>
<h4 id="3闭包">3.闭包</h4>
<p>就是将一个函数的返回值为另一个函数，则另一个函数里的变量值就不会释放，存货并独享状态会一直在缓存中。</p>
<pre><code>func main() {
    //res其实就是test1返回值函数,和之前匿名函数变量一个道理
    res := test1()
    fmt.Println(res()) //输出2
    fmt.Println(res()) //输出3
    fmt.Println(res()) //输出4
}
//注意此处,返回值类型是func int
func test1() func() int {
    i := 1
    return func() int {
        i = i + 1
        return i
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法-二分查找]]></title>
        <id>https://zhenxu138.github.io/edison.github.io/post/suan-fa-er-fen-cha-zhao/</id>
        <link href="https://zhenxu138.github.io/edison.github.io/post/suan-fa-er-fen-cha-zhao/">
        </link>
        <updated>2021-10-14T10:37:06.000Z</updated>
        <content type="html"><![CDATA[<p>1.思路</p>
<p>2.解题步骤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法-分治法]]></title>
        <id>https://zhenxu138.github.io/edison.github.io/post/suan-fa-fen-zhi-fa/</id>
        <link href="https://zhenxu138.github.io/edison.github.io/post/suan-fa-fen-zhi-fa/">
        </link>
        <updated>2021-10-14T10:32:59.000Z</updated>
        <content type="html"><![CDATA[<p>1.思路</p>
<p>2.解题步骤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-并发模型]]></title>
        <id>https://zhenxu138.github.io/edison.github.io/post/go-bing-fa-mo-xing/</id>
        <link href="https://zhenxu138.github.io/edison.github.io/post/go-bing-fa-mo-xing/">
        </link>
        <updated>2021-10-14T10:21:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="并发模型">并发模型</h1>
<h1 id="1场景">1.场景</h1>
<h5 id="1三个任务ab同时c必须等到ab完成后才能进行">1.三个任务，A,B同时，C必须等到A,B完成后才能进行。</h5>
<p>解析：前两个并发，后一个等待。所以使用sync.WaitGroup</p>
<pre><code class="language-go">	w :=sync.WaitGroup{}
	w.Add(2)
	go func() {
		a()
		w.Done()
	}()
	go func() {
		b()
		w.Done()
	}()
	w.Wait()
	c()
</code></pre>
<p>注意点：done和wait要在外面环境执行</p>
<p>知识点：sync.WaitGroup可以解决同步阻塞等待的问题。</p>
<h5 id="2ab两个任务都需要执行x任务但不能同时做">2.A,B两个任务，都需要执行X任务，但不能同时做。</h5>
<p>解析，两个并发任务，对一个资源信进行抢夺等待，所以要使用锁，sync.mutex。</p>
<pre><code class="language-go">	m:=&amp;sync.Mutex{}
	go func() {
		a(m)
	}()
	go func() {
		b(m)
	}()
	time.Sleep(time.Second*8)
	
func a(m *sync.Mutex)  {
	fmt.Println(&quot;a is start&quot;)
	m.Lock()
	c(&quot;a is using c&quot;)
	m.Unlock()
	fmt.Println(&quot;a is done&quot;)
}
func b(m *sync.Mutex)  {
	fmt.Println(&quot;b is start&quot;)
	m.Lock()
	c(&quot;b is using c&quot;)
	m.Unlock()
	fmt.Println(&quot;b is start&quot;)
}
func c(s string)  {
	fmt.Println(s)
	time.Sleep(4*time.Second)
	fmt.Println(s)
}
</code></pre>
<p>注意点：锁是指针类型，得传引用。</p>
<p>知识点：sync.Mutex可以解决对资源同步问题。</p>
<h5 id="3abc三个争夺资源xa做的时候bc不能做">3.ABC,三个争夺资源x.A做的时候，BC不能做。</h5>
<p>解析：首先也是资源争夺，A做的时候上锁，其他对资源的争夺有限制，为读写锁。</p>
<pre><code class="language-go">func a(m *sync.RWMutex)  {
	fmt.Println(&quot;a is start&quot;)
	m.Lock()
	x(&quot;a is using x&quot;)
	m.Unlock()
	fmt.Println(&quot;a is done&quot;)
}
func b(m *sync.RWMutex)  {
	fmt.Println(&quot;b is start&quot;)
	m.RLock()
	x(&quot;b is using x&quot;)
	m.RUnlock()
	fmt.Println(&quot;b is start&quot;)
}
func c(m *sync.RWMutex)  {
	fmt.Println(&quot;c is start&quot;)
	m.RLock()
	x(&quot;c is using x&quot;)
	m.RUnlock()
	fmt.Println(&quot;c is start&quot;)
}
</code></pre>
<p>注意点：如果控制几个方法对一个资源使用，需要对几个方法都使用锁，只是锁的类型不同。</p>
<p>知识点：锁比读锁权限高。同一Rlock也是同时并发使用资源。</p>
<h4 id="4ab两个任务b依赖a中的数据x">4.A,B两个任务，B依赖A中的数据x。</h4>
<p>解析：两个并发中的数据同步问题。一般使用channel来同步并发数据。</p>
<pre><code>	m:=make(chan int)
	go func() {
		a(m)
	}()
	go func() {
		b(m)
	}()
func a(m chan&lt;- int)  {
	fmt.Println(&quot;a is start&quot;)
	time.Sleep(4*time.Second)
	m&lt;- 1
	fmt.Println(&quot;a is 1&quot;)
}
func b(m &lt;-chan int)  {
	fmt.Println(&quot;b is start&quot;)
	b:= &lt;- m
	fmt.Println(&quot;b get a :&quot;,b)
}
</code></pre>
<p>注意点：chan需要赋值，有内存地址，new一个。才能读取。</p>
<p>知识点：channel使用要知道哪里结束，同步的时候，chan可以转换为只读和只写。</p>
<h4 id="5一个任务有ab两个功能但是a功能不稳定超过3秒就结束方法退出方法">5.一个任务有A,B两个功能，但是A功能不稳定，超过3秒就结束方法，退出方法。</h4>
<p>解析：因为两个功能，所以有数据同步，使用channel。有一个可以取消，所以可以定义个quit管道，专门处理异常退出。</p>
<pre><code class="language-go">func A()  {
	cancel:=time.After(3*time.Second)
	done:=make(chan int)
	go x(done)

	select {
	case &lt;-done:
		fmt.Println(&quot;get data success!&quot;)
		return
	case &lt;-cancel:
		fmt.Println(&quot;time out.&quot;)
		return
	}
}
func B()  {
	fmt.Println(&quot;b is start&quot;)
	time.Sleep(5*time.Second)
	//b:= &lt;- m
	fmt.Println(&quot;b get a &quot;)
}
func x(done chan int)  {
	time.Sleep(4*time.Second)
	done&lt;- 1
	fmt.Println(&quot;x spend 4 seconds.&quot;)
}
</code></pre>
<p>注意点：在A方法里，实现两个channel，一个设置时间超时，一个用来处理数据方法。再用select判断哪个可以执行。</p>
<p>知识点：使用chan和select搭配来支持优雅的退出过程，退出的方法在写并发的时候一定要先确定好，保持系统稳定。</p>
<h4 id="6一个工作需要处理n个a方法但是一次处理太多会导致效率问题所以设置每次只处理10个-使用有缓存的channel">6.一个工作需要处理N个A方法，但是一次处理太多会导致效率问题，所以设置每次只处理10个。使用有缓存的channel。</h4>
<pre><code class="language-go">func A(i int) {
    fmt.Println(&quot;task A &quot;, i)
    time.Sleep(time.Second )
}
func main() {
     done := make(chan int, 10)
     for i := 0; i &lt; 100; i ++ {
        go func(i int) {
            done &lt;- 1
            A(i)
            &lt;-done
        }(i)
    }
     time.Sleep(time.Minute)
}
或者
func A(i chan int)  {
	time.Sleep(4*time.Second)
	fmt.Println(&quot;task i:&quot;,&lt;-i)
}
	done:=make(chan int,10)
	for i:=0;i&lt;40;i++{
		go func(i int) {
			//fmt.Println(&quot;i:&quot;,i)
			done&lt;- i
			A(done)
		}(i)
	}
</code></pre>
<p>注意点：缓存的channel要最先定义，</p>
<p>知识点：使用缓存可以控制并发量。</p>
<h1 id="2并发模式">2.并发模式</h1>
<h4 id="1生产者消费者模型">1.生产者，消费者模型</h4>
<p>解析：就是两方解耦，一边生成数据，一边使用数据。使用有缓存的channel。</p>
<pre><code class="language-go">	done:=make(chan int,10)

	go A(done)
	for i:=0;i&lt;40;i++ {
		go B(done)
	}
func A(ch chan&lt;- int)  {
	for i:=0;i&lt;40;i++{
		ch&lt;-i*100
		fmt.Println(&quot;task A:&quot;,i)
        }
}
func B(ch &lt;-chan int)  {
	temp:=&lt;-ch
	time.Sleep(4*time.Second)
	fmt.Println(&quot;task B:&quot;,temp)
}
</code></pre>
<p>注意点：go 在for前面和for后面是有区别的，go for的话是串行，for go才是并行。</p>
<p>知识点：一个产生，一个消费，channel作为缓存队列。</p>
<h4 id="2发布订阅">2.发布订阅</h4>
<p>解析：生产者和消费者是M:N的关系。在传统生产者和消费者模型中，是将消息发送到一个队列中，而发布订阅模型则是将消息发布给一个主题。</p>
<p>每个订阅者就是增加一个channel，每次发主题就是消息就从channel里写数据。</p>
<pre><code class="language-go">type (
	subscriber chan interface{}		//订阅者为一个管道
)

type Publisher struct {
	m sync.RWMutex
	buffer int
	timeout time.Duration
	subscribers map[subscriber]string
}

//新建一个发布者
func NewPublisher(Timeout time.Duration, buffer int) *Publisher {
	return &amp;Publisher{
		m: sync.RWMutex{},
		buffer: buffer,
		timeout: Timeout,
		subscribers: map[subscriber]string{},
	}
}

//订阅者订阅,就是增加map里的channel
func (p *Publisher)subscrib(topic string) chan interface{} {
	ch:=make(chan interface{},p.buffer)
	p.subscribers[ch]= topic
	return ch
}

//退出订阅,删除map里的channel
func (p *Publisher)Evistsubscrib(sub chan interface{}) {
	delete(p.subscribers,sub)
	close(sub)
}
//发布主题
func (p *Publisher)Publish(sub chan interface{}) {
	wg:=sync.WaitGroup{}
	for sub,topic:=range p.subscribers{
		wg.Add(1)
		go sendTopic(sub,topic,&amp;wg,p.timeout)
	}
	wg.Wait()
}
//发送主题
func sendTopic(ch chan interface{},topic string,wg *sync.WaitGroup,duration time.Duration)  {
	defer wg.Done()
	select {
	case ch&lt;-topic:
	case &lt;-time.After(duration):
	}
}
</code></pre>
<h1 id="3答疑">3.答疑</h1>
<p><strong>1.什么时候要选择关闭通道，遍历一个未关闭的channel会造成死循环.但只要没有goroutine持有channel，相关资源会自动释放</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库学习-SORM组件学习]]></title>
        <id>https://zhenxu138.github.io/edison.github.io/post/shu-ju-ku-xue-xi-sorm-zu-jian-xue-xi/</id>
        <link href="https://zhenxu138.github.io/edison.github.io/post/shu-ju-ku-xue-xi-sorm-zu-jian-xue-xi/">
        </link>
        <updated>2021-10-14T09:08:28.000Z</updated>
        <content type="html"><![CDATA[<p>公共组件做了数据库抽象层：sorm，所以业务不直接写数据库原生的sql，遵循sorm组件语法开发</p>
<h3 id="1模型的概念">1.模型的概念：</h3>
<p>模型就是数据库的<mark>表结构</mark>，对应到go中就是go的结构体，可以通过给结构体增加orm属性的tag来指定这个字段的属性，比如主键,索引等。</p>
<pre><code class="language-go">type TessResultDetail struct {
   Id       int64  `orm:&quot;pk;column(_id)&quot; bson:&quot;_id&quot;`
   ResultId int64  `orm:&quot;index;column(result_id)&quot; bson:&quot;result_id&quot;`
   CheckId  string `orm:&quot;index;column(check_id)&quot; bson:&quot;check_id&quot; `
   Name     string `orm:&quot;column(name)&quot; bson:&quot;name&quot; json:&quot;name&quot;`
   Score int32 `bson:&quot;score&quot; json:&quot;score&quot;`
   Scope int32 `bson:&quot;scope&quot; json:&quot;scope&quot;`
   CheckStd string `bson:&quot;check_std&quot; json:&quot;check_std&quot;`
   Result int32 `bson:&quot;result&quot; json:&quot;result&quot;` 
   Description  string `bson:&quot;description&quot; json:&quot;description&quot;`
   Extend       string `bson:&quot;extend&quot; json:&quot;extend&quot;`
   CheckContent string `bson:&quot;check_content&quot; json:&quot;check_content&quot;`
}
</code></pre>
<p>模型初始化，模型注册</p>
<pre><code class="language-go">func init() {
  	orm.RegisterModel(new(model.TessResultDetail))
    o := orm.NewOrmWithDb(provider.DefaultDB())
    o.RegisterTable(new(model.TessResultDetail))
}
</code></pre>
<p>ORM模型对象的组成：</p>
<ul>
<li>表名table</li>
<li>主键</li>
<li>索引（普通索引，UNIQUE 索引，组合索引）</li>
<li>表列（列名）</li>
<li>关联表对象</li>
<li>支持的数据类型以及标注</li>
</ul>
<h5 id="数据库注册">数据库注册</h5>
<pre><code>//注册数据库示例：
var info orm.OrmDbRegisterInfo
info.DbType = &quot;mongo&quot;
info.Host = &quot;127.0.0.1:27017&quot;
...
info.AliasName = &quot;default&quot;//必须指定一个default数据库，通过这里的别名实现
initSetting := make(map[string]string)
initSetting[&quot;create_table&quot;] = &quot;true&quot;
info.Opts = initSetting//设置选项
 
orm.RegisterDataBaseWithOpt(info)
</code></pre>
<h2 id="2基本api">2.基本API</h2>
<h4 id="查找read">查找read</h4>
<h5 id="1根据某一值查找单条数据func-o-orm-readone-value-interface-fields-string-error">1.根据某一值查找单条数据：func ( o *orm ) ReadOne (value interface{} , fields ... string ) error</h5>
<pre><code class="language-go">user := User{UId: &quot;100001199508049527&quot;}
err = o.ReadOne(&amp;user,&quot;UId&quot;)

sd := &amp;model.Standard{Id: id}
err := orm.NewOrmWithDb(s.hook.DefaultDB()).ReadOne(sd, &quot;_id&quot;)
</code></pre>
<h5 id="2查找或创造funco-orm-readoneorcreate-value-interface-field1-string-fields-string-bool-error">2.查找或创造：func(o *orm) ReadOneOrCreate (value interface{}, field1 string, fields ...string) (bool, error)</h5>
<pre><code class="language-go">o := orm.NewOrm()
user := User{Name: &quot;Jeff&quot;}
user := User{UId: &quot;100001199508049527&quot;}
if created, err := o.ReadOneOrCreate(&amp;user, &quot;UId&quot;); err == nil {
  if created {
    fmt.Println(&quot;New Insert an object. Id:&quot;, id)
  } else{
    fmt.Println(&quot;Get an object. Id:&quot;, id)
  }
}
</code></pre>
<h4 id="插入数据">插入数据</h4>
<h5 id="1插入一条数据func-o-orm-insertvalue-interface-error">1.插入一条数据：func( o *orm )Insert(value interface{}) error</h5>
<pre><code class="language-go">var user User
user.Name = &quot;Jack&quot;
err := o.Insert(&amp;user)

standar := model.NewStandard(id, name, assetID, desc, creator, clientType, isInner)
err := orm.NewOrmWithDb(s.hook.DefaultDB()).Insert(standar)
</code></pre>
<h5 id="2插入多条func-o-orm-insertmultiint-bulkvalues-interface-opt-ormorminsertmultiopt-int64error">2.插入多条：func( o *orm )InsertMulti(int bulk,values [] interface{}, opt ...orm.OrmInsertMultiOpt) (int64,error)</h5>
<pre><code class="language-go">users := []User{
  {Name: &quot;Jack&quot;},
  {Name: &quot;Bob&quot;},
  {Name: &quot;unknown&quot;},
  ...
}
successNums, err := o.InsertMulti(len(users), &amp;users)
</code></pre>
<h4 id="更改数据">更改数据</h4>
<h5 id="1更改单条数据func-o-orm-updatevalue-interface-fields-string-int64-error">1.更改单条数据：func ( o *orm )Update(value interface{} , fields ... string )(int64, error)</h5>
<pre><code class="language-go">//更新全部字段
o := orm.NewOrm()
user := User{ID: &quot;1&quot;}
if o.Read(&amp;user) == nil {
  user.Name = &quot;MyName&quot;
  if num, err := o.Update(&amp;user); err == nil {
    fmt.Println(num)
  }
}
</code></pre>
<h5 id="2更改单条数据的某个数据">2.更改单条数据的某个数据</h5>
<pre><code class="language-go">o.Update(&amp;user, &quot;Name&quot;)
// 指定多个字段
// o.Update(&amp;user, &quot;Field1&quot;, &quot;Field2&quot;, ...)
</code></pre>
<h5 id="3插入或更改func-s-orm-insertorupdatemd-interface-uniquecols-string-updatecols-string-error">3.插入或更改：func (s *Orm) InsertOrUpdate(md interface{}, uniquecols []string, updatecols ...string) error</h5>
<pre><code>//根据联合唯一索引Name 和 Age 匹配，若数据库存在则更新所有字段，否则插入该条数据
err := o.InsertOrUpdate(intnew, []string{&quot;Name&quot;, &quot;Age&quot;})
</code></pre>
<pre><code class="language-go">//根据联合唯一索引Name 和 Age 匹配，若数据库存在,只更新&quot;Addr&quot;, &quot;Level&quot;字段，否则插入该条数据
err = o.InsertOrUpdate(intnew, []string{&quot;Name&quot;, &quot;Age&quot;}, []string{&quot;Addr&quot;,&quot;Level&quot;}...)
</code></pre>
<h4 id="删除数据">删除数据</h4>
<h5 id="1删除-funco-orm-deletevalue-interface-error根据主键进行删除">1.删除： func(o *orm) Delete(value interface{}) error//根据主键进行删除</h5>
<pre><code class="language-go">o := orm.NewOrm()
user := User{UId: ``&quot;100001199508049527&quot;``}
o.ReadOne(&amp;user, ``&quot;UId&quot;``)
err:= o.Delete(user)
if err != nil{
  fmt.Println(err)
}
</code></pre>
<h3 id="3复杂查询querytable">3.复杂查询QueryTable</h3>
<pre><code>type User struct {
    ID   string `orm:&quot;pk&quot;`
    Name string
}
//使用结构体对象
var user User
qs :=orm.NewOrm().QueryTable(user)
//使用结构体指针
if qs == nil {
  log.Errorf(&quot;QueryTable got QuerySet nil&quot;)
}
user := new(User)
qs :=orm.NewOrm().QueryTable(user)
if qs == nil {
    log.Errorf(&quot;QueryTable got QuerySet nil&quot;)
}
</code></pre>
<h4 id="1-withfilter操作范围符">1. WithFilter操作范围符</h4>
<h5 id="exact等于">exact等于</h5>
<pre><code>qs.WithFilter(&quot;name__exact&quot;, &quot;Jack&quot;) // WHERE name = 'Jack'
</code></pre>
<h5 id="ne不等于">ne不等于</h5>
<pre><code>qs.WithFilter(``&quot;age__ne&quot;``, 17)// WHERE age != 17
</code></pre>
<h5 id="gt-gte-大于-大于等于">gt / gte 大于 / 大于等于</h5>
<pre><code>qs.WithFilter(``&quot;age__gt&quot;``, 17)``// WHERE age &gt; 17` 
qs.WithFilter(``&quot;age__gte&quot;``, 18)``// WHERE age &gt;= 18
</code></pre>
<h5 id="lt-lte-小于-小于等于">lt / lte 小于 / 小于等于</h5>
<pre><code>qs.WithFilter(``&quot;age__lt&quot;``, 17)// WHERE age &lt; 17
</code></pre>
<pre><code>qs.WithFilter(``&quot;age__lte&quot;``, 18)// WHERE age &lt;= 18
</code></pre>
<h5 id="containsicontains-包含">contains/icontains 包含</h5>
<pre><code>qs.WithFilter(``&quot;name__contains&quot;``, ``&quot;Jack&quot;``)``// 大小写敏感, 匹配包含 Jack的字符qs.WithFilter(``&quot;name__icontains&quot;``, ``&quot;JACK&quot;``)``// 不区分大小写, 匹配包含 Jack的字符
</code></pre>
<h5 id="startwithistartwith以-起始">startwith/istartwith以。。。起始</h5>
<pre><code>qs.WithFilter(``&quot;name__startwith&quot;``, ``&quot;Jack&quot;``)// 大小写敏感, 匹配以 'Jack' 起始的字符串
qs.WithFilter(``&quot;name__istartwith&quot;``, ``&quot;JACK&quot;``)// 不区分大小写, 匹配以 'Jack' 起始的字符串
</code></pre>
<h5 id="endwithiendwith-以-结束">endwith/iendwith 以。。结束</h5>
<pre><code>qs.WithFilter(``&quot;name__endwith&quot;``, ``&quot;Jack&quot;``)``// 大小写敏感, 匹配以 'Jack' 结束的字符串qs.WithFilter(``&quot;name__endwith&quot;``, ``&quot;JACK&quot;``)``// 不区分大小写, 匹配以 'Jack' 结束的字符串
</code></pre>
<h5 id="in在集合中">in在集合中</h5>
<pre><code>ids:=[]``int``{17,18,19,20}``qs.WithFilter(``&quot;age__in&quot;``, ids)``// WHERE age IN (17, 18, 19, 20)
</code></pre>
<h4 id="2withfilter过滤查询">2.<strong>WithFilter</strong>过滤查询</h4>
<h5 id="count查询返回数量">count：查询返回数量</h5>
<pre><code>qs := orm.QueryTable(``new``(User))
qs := qs.WithFilter(&quot;name&quot;``, ``&quot;Jack&quot;``)
num,err := qs.Count())
</code></pre>
<h5 id="all返回结果集结果切片">all：返回结果集（结果切片）</h5>
<pre><code>qs := orm.QueryTable(``new``(User))``
qs := qs.WithFilter(``&quot;name&quot;``, ``&quot;Jack&quot;``)`
`var users []*User``
num,err := qs.All(&amp;users,``&quot;name&quot;``)
</code></pre>
<h5 id="one查询结构集中的单条记录">one：查询结构集中的单条记录。</h5>
<h5 id="oneautolnc对结果集单条记录">oneAutolnc:对结果集单条记录</h5>
<h5 id="withorderby对查询结果集进行排序">withorderby:对查询结果集进行排序</h5>
<h5 id="withlimit限制数据条数和偏移">withlimit:限制数据条数和偏移</h5>
<pre><code class="language-go">QueryTable(new(model.TessResult)).WithFilter(&quot;mid&quot;, mid).WithLimit(1, 0).WithOrderBy(&quot;created_at&quot;, -1).One(info)
</code></pre>
<h5 id="distinct查询不重复的">Distinct:查询不重复的</h5>
<h5 id="newgroupby分组操作func-s-queryset-newgroupsgroupbycols-string-groups">Newgroupby：分组操作=func (s *QuerySet) NewGroups(groupByCols []string) *Groups</h5>
<pre><code>qs := orm.QueryTable(new(User))
qs := qs.WithFilter(``&quot;name&quot;``, ``&quot;Jack&quot;)//Count聚合操作rs,err := qs.NewGroups([]string{``&quot;age&quot;``}).Count()``//Sum聚合操作//rs,err := qs.NewGroups([]string{&quot;age&quot;}).Sum(&quot;salary&quot;)``//Max聚合操作``//rs,err := qs.NewGroups([]string{&quot;age&quot;}).Max(&quot;salary&quot;)``//Min聚合操作``//rs,err := qs.NewGroups([]string{&quot;age&quot;}).Min(&quot;salary&quot;)``//Avg聚合操作``//rs,err := qs.NewGroups([]string{&quot;age&quot;}).Avg(&quot;salary&quot;)
</code></pre>
<h5 id="qsupdate批量更新func-s-queryset-qsupdatevalues-mapstringinterface-int64-error">QsUpdate：批量更新==func (s *QuerySet) QsUpdate(values map[string]interface{}) (int64, error)</h5>
<pre><code>val := make(map[string]interface{})``
val[``&quot;name&quot;``] = ``&quot;Bob&quot;``
num, err := o.QueryTable(``new``(User)).WithFilter(``&quot;name&quot;``,``&quot;Jack&quot;``).QsUpdate(val)``
fmt.Printf(``&quot;Matched Num: %s, %s&quot;``, num, err)``
// SET name = &quot;Bob&quot; WHERE name = &quot;Jack&quot;
</code></pre>
<h5 id="qsdelete">QsDelete</h5>
<pre><code>num, err := o.QueryTable(new(User)).WithFilter(``&quot;name&quot;``, ``&quot;Jack&quot;``).QsDelete()
fmt.Printf(``&quot;Affected Num: %s, %s&quot;``, num, err)
// DELETE FROM user WHERE name = &quot;Jack&quot;
</code></pre>
<h4 id="关联查询连接">关联查询（连接）</h4>
<h5 id="func-s-queryset-withloadrelatedcols-string-queryset">func (s *QuerySet) WithLoadRelated(cols ...string) *QuerySet</h5>
<p>问题：关联的时候先withfilter.再使用withloadrelated对这一结构中的关联数据限制</p>
<pre><code>type ClientPatchData struct {      
    ID       string `orm:&quot;pk;size(128);column(_id);auto&quot;`
 
    ClientMeta *Meta  `orm:&quot;rel(one,ref=MetaID)&quot;`
    //MetaID为1:1关联关系存储ID列，业务无需关心此字段也不允许操作此字段，此字段类型必须与Meta主键类型一致
    MetaID     string `orm:&quot;size(128);column(meta_id)&quot;`
 
    Kbids   []*Kbid         `orm:&quot;rel(m2m)&quot;`
}
//查出ClientPatchData.ID=&quot;ClientPatchData_ID&quot;的一条数据，同时查出与之关联的Meta和Kbid数据;关联关系的建立详看Association相关api
qsPatch := ``new``(ClientPatchData)
err := o.QueryTable(qsPatch).WithFilter(``&quot;ID&quot;``, ``&quot;ClientPatchData_ID&quot;``).WithLoadRelated(``&quot;ClientMeta&quot;``,``&quot;Kbids&quot;``).One(qsPatch)
</code></pre>
<h5 id="withcond自定义条件表达式">withcond自定义条件表达式</h5>
<pre><code>/ and AndCond (and AndNot orNot OrNotCond (and AndNot))假设0123456789这10个值
qs := o.QueryTable(user)
cond := orm.NewCondition().And(``&quot;name__contains&quot;``,``&quot;Test_Condition&quot;``))
cond1 := cond.AndNot(``&quot;age__gt&quot;``, users[3].Age).OrNot(``&quot;age__gt&quot;``, users[4].Age) ``//!(&gt;3)||!(&gt;4) 等价于 &lt;=3||&lt;=4     result:01234
cond2 := cond.AndNot(``&quot;age__gt&quot;``, users[5].Age)                 //!(&gt;5) 等价于 &lt;=5           result:012345
cond3 := cond1.OrNotCond(cond2)                        //01234||!(012345) 等价于 01234||6789 result:012346789
qs.WithCond(cond.AndCond(cond3))
qs.All(userResults)                              //result:012346789
</code></pre>
<p>首先要newcondition得到。</p>
<h4 id="withjoin连接操作">=<mark>Withjoin：连接操作</mark>=</h4>
<p>func (s *QuerySet) WithJoin( joinMode string, qsRight *QuerySet, on *Condition) *QuerySet</p>
<p>问题：不是很会</p>
<h2 id="associationdotransaction">Association，DoTransaction：</h2>
<p>对关联数据操作时，两个表，需要使用事务。</p>
<pre><code>err := so.DoTransaction(func() error {
		err := so.Delete(info)
		if err != nil {
			log.Errorf(&quot;DeleteStandardMeta rule: %v error: %+v&quot;, info, err)
			return err
		}
		_, err = so.QueryTable(new(model.StandardCheck)).WithFilter(&quot;standard&quot;, info.Id).QsDelete()
		if err != nil {
			log.Errorf(&quot;DeleteStandardCheck rule: %v error: %+v&quot;, info, err)
			return err
		}
		return nil
	})
	return err
}
</code></pre>
<h5 id="是一对一多对多关联关系的增加更新删除等操作接口每一个操作都自带事务">是一对一，多对多关联关系的增加，更新，删除等操作接口，每一个操作都自带事务。</h5>
<p>1.先删除关联关系，再删除数据。</p>
<p>先删除model.Standard，再删除相关联的model.StandardCheck。</p>
<h3 id="migration能力">Migration能力：</h3>
<p>为服务端软件升级带来的数据库存储层面，提供通用的数据库升级相关的基础能力。</p>
<p>用来链接数据库、检查数据库存在、创建数据库和关闭数据库的接口。</p>
<p>作业：</p>
<ol>
<li>找一个环境（本地或者开发机都可以）安装mongo和PostgreSQL</li>
<li>用命令行完成数据操作命题（手写sql）：
<ol>
<li>新建一个school库</li>
<li>新建student （包含id，姓名、班级id、年龄 字段） 和 class（包含id，名称）表，</li>
<li>插入2条class数据，5条student数据</li>
<li>将所有学生年龄 + 1</li>
<li>获取每个班的平均年龄、总人数、班级名称</li>
<li>删除一个学生信息</li>
</ol>
</li>
</ol>
<p>问题：</p>
<p>\l 查看数据库</p>
<p>\c进入数据库</p>
<p>\d查看表</p>
<p>1.注册表=注册模型？</p>
<p>先要注册模型，然后连接数据库后。注册表再来使用使用表，进行操作。</p>
<p>2.怎么设置关联？</p>
<pre><code>//学生表
type StudentOne struct {
   ID string    `orm:&quot;size(128);pk;auto&quot;`
   Name string  `orm:&quot;size(128)&quot;`
   Class *ClassOne `orm:&quot;rel(one,ref=StudentClassID)&quot;`//只需要再顶一个id。
   StudentClassID string`orm:&quot;size(128);colum(student_class_id)&quot;`
   Age int
   motto string
}
//班级表
type ClassOne struct {
   ID string `orm:&quot;pk;size(128);column(_id);auto&quot;`
   Name string`orm:&quot;size(128);column(name)&quot;`
}
</code></pre>
<p>CheckRelationLable check rel ref col on table student col ClassID got error</p>
<p>使用步骤：</p>
<p>1.设置数据库的信息ingo</p>
<pre><code>initSetting := make(map[string]string)
initSetting[&quot;create_table&quot;] = &quot;true&quot;
initSetting[&quot;no-framework&quot;] = &quot;true&quot;
var info orm.OrmDbRegisterInfo
info.User = &quot;postgres&quot;
info.Psw = &quot;QAXwolaile12345&quot;
info.Host = &quot;localhost:5432&quot;
info.DbType = &quot;pg&quot;
info.DbName = &quot;school&quot;
info.Opts = initSetting
info.AliasName = &quot;default&quot;
</code></pre>
<p>2.在orm对象中注册数据库信息，连接数据库。</p>
<pre><code>e := orm.RegisterDataBaseWithOpt(info)
if e != nil {
   log.Println(e)
}
</code></pre>
<p>3.连接以后，选择使用的数据表，注册模型。</p>
<pre><code>//学生表
type StudentOne struct {
   ID             string    `orm:&quot;size(128);pk;auto&quot;`
   Name           string    `orm:&quot;size(128)&quot;`
   Class          *ClassOne `orm:&quot;rel(one,ref=StudentClassID)&quot;`
   StudentClassID string    `orm:&quot;size(128);colum(student_class_id)&quot;`
   Age            int
   motto          string
}

//班级表
type ClassOne struct {
   ID   string `orm:&quot;pk;size(128);column(_id);auto&quot;`
   Name string `orm:&quot;size(128);column(name)&quot;`
}
</code></pre>
<pre><code>orm.RegisterModel(new(StudentOne), new(ClassOne))
</code></pre>
<p>4.注册模型以后，就选择不同的表进行操作，没有表名就自动创建&quot;student_dynamic&quot;。</p>
<pre><code>e = orm.NewOrm().RegisterTable(new(StudentOne), &quot;student_dynamic&quot;)
if e != nil {
   log.Println(e)
}
</code></pre>
<p>5.要对不同表进行操作时，首先对orm对象进行申请，然后用orm的usingTable进行指定表名。</p>
<pre><code>//orm对象申请（因为已经注册了缺省数据库，所以直接调用）
o := orm.NewOrm()
//指定表结构
o.UsingTable(&quot;student_dynamic&quot;)
</code></pre>
<p>6.然后根据需求进行API操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git合并问题]]></title>
        <id>https://zhenxu138.github.io/edison.github.io/post/git-he-bing-wen-ti/</id>
        <link href="https://zhenxu138.github.io/edison.github.io/post/git-he-bing-wen-ti/">
        </link>
        <updated>2021-10-14T08:45:02.000Z</updated>
        <content type="html"><![CDATA[<p>1.新建仓库<br>
先创建project，再创建文件。</p>
<h5 id="git-global-setup">Git global setup</h5>
<pre><code>git config --global user.name &quot;zhengxurui&quot;
git config --global user.email &quot;zhengxurui@qianxin.com&quot;
</code></pre>
<h5 id="create-a-new-repository">Create a new repository</h5>
<pre><code>git clone git@git-open.qianxin-inc.cn:free/zhengxurui/sorm-demo.git
cd sorm-demo
touch README.md
git add README.md
git commit -m &quot;add README&quot;
git push -u origin master
</code></pre>
<h5 id="push-an-existing-folder">Push an existing folder</h5>
<pre><code>cd existing_folder
git init
git remote add origin git@git-open.qianxin-inc.cn:free/zhengxurui/sorm-demo.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
</code></pre>
<h5 id="push-an-existing-git-repository">Push an existing Git repository</h5>
<pre><code>cd existing_repo
git remote rename origin old-origin
git remote add origin git@git-open.qianxin-inc.cn:free/zhengxurui/sorm-demo.git
git push -u origin --all
git push -u origin --tags
</code></pre>
<p>2.更新代码<br>
1.进行这个步骤之前要完成前面的步骤<br>
2.关联到远程仓库：git remote add origin 地址<br>
3.将远程库与本地同步合并：git pull --rebase origin<br>
4.将本地库的内容推送到远程，使用git push 命令：git push -u origin</p>
<p>3.删除数据<br>
$ git pull origin master  # 将远程仓库里面的项目拉下来<br>
$ dir # 查看有哪些文件夹<br>
$ git rm -r --cached target  # 删除你要删除的文件名称，这里是删除target文件夹（cached不会把本地的flashview文件夹删除）<br>
$ git commit -m '删除了target' # 提交,添加操作说明<br>
git push -u origin master #重新提交（若需要对其他分支进行操作，则把master换为对应分支，如:git push -u origin dev）</p>
<p>4.克隆分支，并新建分支</p>
<ol>
<li>克隆远程master仓库的某一个分支</li>
</ol>
<pre><code class="language-bash">git clone -b &lt;指定分支名&gt; &lt;远程仓库地址&gt;
git clone -b master git@......(url)
</code></pre>
<ol start="2">
<li>本地切换并新建分支</li>
</ol>
<pre><code class="language-bash">git checkout -b &lt;本地分支名&gt;
git checkout -b personal
</code></pre>
<ol start="3">
<li>添加远程主机名为personal的分支</li>
</ol>
<pre><code class="language-bash">git remote add &lt;远程主机名&gt; &lt;git地址&gt;
git remote add personal git@......(url)
</code></pre>
<ol start="4">
<li>将本地的personal内容传到个人分支上的personal</li>
</ol>
<pre><code class="language-bash">git add .
git commit -m &quot;fritst&quot;
git push &lt;远程主机名&gt;(remote的名字) &lt;本地分支名&gt;:&lt;远程分支名&gt;（远程真正创建的名字）
git push origin personal
</code></pre>
<p>5.merge代码<br>
1.pull代码到自己本地<br>
2.如果有冲突，需要git stash将自己的代码存入缓存区。<br>
3.然后再次pull远程代码到工作区间<br>
4.git stash pop更新代码，手动解决冲突。<br>
5.修改后再add commit push，完成代码更新。</p>
<p>6.删除分支</p>
<pre><code class="language-bash">git branch -D dev/pzqu2
</code></pre>
<p>删除远端分支</p>
<pre><code class="language-bash">git push  origin --delete dev
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lazy man 个人博客]]></title>
        <id>https://zhenxu138.github.io/edison.github.io/post/hello-gridea/</id>
        <link href="https://zhenxu138.github.io/edison.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>✍️  <strong>Gridea</strong>本人博客用来记录个人的生活、心情、知识、笔记、创意... ...</p>
<p><a href="https://github.com/getgridea/gridea">Github</a></p>
<h2 id="内容包括">内容包括👇</h2>
<p>📝</p>
<p>🌉</p>
<p>🏷️</p>
<p>📋</p>
<p>💻</p>
<p>🌎</p>
<p>💬</p>
<p>🌁</p>
<p>🖥</p>
<p>🌱</p>
<p>🏃</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>